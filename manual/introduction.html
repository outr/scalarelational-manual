<!DOCTYPE html><html lang="en-GB">
        <head>
          <title>ScalaRelational User Manual v1.1.0 - Introduction</title>
          <meta charset="utf-8"/>
          <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
          <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
          <meta name="generator" content="MetaDocs"/>
          <link rel="shortcut icon" href="images/favicon.ico"/>
          
          <link rel="stylesheet" type="text/css" href="css/kult.css"/><link rel="stylesheet" type="text/css" href="css/highlight.css"/>
        </head>

        <body>
          <div id="wrapper">
      <header>
            <h1 class="title">ScalaRelational User Manual v1.1.0</h1>
          </header><nav><a href="index.html">Table of contents</a>  |  <span>Next chapter: <a href="getting-started.html">Getting Started</a></span></nav><h1 id="introduction">Introduction</h1><p><i>ScalaRelational</i> is a database framework which provides a type-safe DSL for SQL in Scala. The goal in its design is to be a thin layer over SQL, making it one of the fastest database abstractions for the Scala programming language.</p><h2 id="why-not-an-orm">Why not an ORM?</h2><p>Unlike an ORM, in ScalaRelational you write SQL queries in a DSL that closely matches up to standard SQL. This has the benefit that the database interaction is transparent and queries can be debugged easily. An abstraction can also be written on top of this to simplify querying without compromising performance.</p><p>There has been a shift recently away from ORMs since they tend to focus only on the most simplistic use-cases for dealing with your database. An ORM complicates matters should you have a more complex usage scenario, like cascading relationships. In addition, the performance penalties (i.e. inefficient queries) are pretty substantial. Other downsides are missing features and confusing code mapping.
  </p><h2 id="why-not-interpolation">Why not Interpolation?</h2><p>There are SQL frameworks (such as <a href="https://github.com/tpolecat/doobie">Doobie</a>) that use string interpolation to achieve type-checked queries. They have the advantage that no new DSL needs to be learned as raw SQL queries can be written within Scala code.</p><p>On the other hand, the queries are not compositional. It may be required to return an incomplete query from a function and refine it in different parts of the application with a conditional <code>WHERE</code> clause. This would allow manual string manipulations, which is error-prone.</p><p>Finally, the most common frustration point of SQL interpolation over time is having similar but not identical queries you end up copy-pasting and making changes since you cannot re-use any part of the query.
  </p><h2 id="why-not-functionalrelational-programming">Why not Functional-Relational Programming?</h2><p>FRP frameworks with <a href="http://slick.typesafe.com/">Slick</a> as a precursor have gained some popularity. They allow generation of SQL queries from a more functional-inspired querying syntax that involve functions like <code>filter()</code> or <code>for ... yield</code> expressions. The following example would correspond to the SQL query <code>SELECT name FROM people</code>.</p><pre class="sourceCode scala"><code data-lang="scala">for { p &lt;- people } yield p.name</code></pre><p>Unfortunately, the diverging syntax limits the readability and potential use case scenarios.</p><p>The biggest problem a framework like Slick has is in fact its abstraction. Though it is convenient to work with a database like a Scala collection, the magic being done behind the scenes is often inefficient and you have no control to optimise your queries.
  </p><h2 id="our-approach-dsl-and-mapper">Our approach: DSL and Mapper</h2><p>It is worth mentioning that much of the functionality of this framework was inspired by the aforementioned database frameworks.</p><p>The main contribution from ORMs is that mapping classes to and from the database is a huge time saver and leads to code that is more maintainable. From interpolating frameworks we took the idea of an SQL-inspired DSL, but with the requirement of staying as close as possible to its syntax.</p><p>Another design decision was to focus on performance and ease-of-use. Therefore, ScalaRelational does not require you to use a code generator and we have made sure that performance-critical parts don't use <i>reflection</i> internally. There is a <a href="https://github.com/outr/scalarelational-benchmarks">benchmark suite</a> we use to regularly compare the performance against other frameworks.</p><h3 id="dsl-for-querying">DSL for querying</h3><p>For each database table, a schema must be defined which records all available columns and, if a table is polymorphic, its sub-types. Columns are statically typed carrying the underlying SQL database type and the mapped Scala type.</p><p>All query types (like <code>INSERT</code> or <code>UPDATE</code>) have a Scala representation, which require you to refer to your schema and the columns in it. Less common SQL features such as query functions (<code>AVG</code>, <code>MIN</code>, <code>MAX</code> etc.) are supported too.</p><h3 id="mapping">Mapping</h3><p>Additionally, ScalaRelational has a sub-project which implements a feature called <i>mapper</i>. Its purpose is two-fold: mapping column values in <code>SELECT</code> queries to a <code>case class</code> and vice-versa (for <code>INSERT</code> or <code>UPDATE</code> queries).</p><p>If a table has many columns and it is not desired to fetch all column values of a row, ScalaRelational gives the ability to have <code>case class</code>es that define a subset.</p><div><b>Todo:</b> Give an example in some other section - Not sure what you mean by this?</div><p>You can represent different scenarios whether you're querying simple data from one table, querying many columns joined across many tables, or dealing with calculated reports generated by a SQL query.
    </p><h2 id="features">Features</h2><ul><li>Type-safe table schemas and queries</li><li>Close Proximity to SQL</li><li>IDE support for queries</li><li>Support for raw SQL queries</li><li>Database-agnostic interface that accounts for differences in SQL implementations</li><li>Modular design</li><li>Optimised for speed</li><li>Extensible API to allow other frameworks to build on top of the existing functionality</li><li>Mapping to and from <code>case class</code>es</li><li>Polymorphic model support</li><li>Database versioning and upgrades</li><li>DSL for DDL generation and manipulation</li></ul><h3 id="database-support">Database support</h3><p>Currently supported databases are:

      </p><ul><li>H2</li><li>PostgreSQL</li><li>MariaDB/MySQL</li></ul><p>Other databases technically are supported though certain functionality may require some slight alterations to work properly. If you need support for other databases, please <a href="support.html">get in touch with us</a>.</p>
      <p><small>Generated with <a href="http://github.com/MetaStack-pl/MetaDocs">MetaDocs</a></small></p>
    </div>
          <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="js/main.js"></script><script src="js/highlight.js"></script>
          <script>hljs.initHighlightingOnLoad();</script>
        </body>
      </html>