<!DOCTYPE html><html lang="en-GB">
        <head>
          <title>ScalaRelational User Manual v1.1.0</title>
          <meta charset="utf-8"/>
          <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
          <meta name="generator" content="MetaDocs"/>
          <link rel="stylesheet" type="text/css" href="../styles/kult.css"/>
        </head>

        <body>
          <div id="wrapper">
            <header>
            <h1 class="title">ScalaRelational User Manual v1.1.0</h1>
          </header><nav><a href="index.html">Table of contents</a>  |  <span>Next chapter: <a href="getting-started.html">Getting Started</a></span></nav><h1 id="introduction">Introduction</h1><p><i>ScalaRelational</i> is a database framework which provides a type-safe DSL for SQL in Scala. The goal in its design is to be a thin layer over SQL, making it one of the fastest database abstractions for the Scala programming language.</p><h2 id="why-not-an-orm">Why not an ORM?</h2><p>Unlike ORMs, ScalaRelational requires you to write regular SQL queries. This has the benefit that the database interaction is transparent and queries can be debugged easily.</p><p>There has been a shift recently away from ORMs since they tend to focus only on the most simplistic use-cases for dealing with your database. An ORM complicates matters should you have a more complex usage scenario, like cascading relationships. In addition, the performance penalties (i.e. inefficient queries) are pretty substantial. Other downsides are missing features and confusing code mapping.
  </p><h2 id="why-not-interpolation">Why not Interpolation?</h2><p>There are SQL frameworks (such as <a href="https://github.com/tpolecat/doobie">Doobie</a>) that use string interpolation to achieve type-checked queries. They have the advantage that no new DSL needs to be learned as raw SQL queries can be written within Scala code.</p><p>On the other hand, the queries are not compositional. It may be required to return an incomplete query from a function and refine it in different parts of the application with a conditional <code>WHERE</code> clause. This would allow manual string manipulations, which is error-prone.</p><h2 id="why-not-functionalrelational-programming">Why not Functional-Relational Programming?</h2><p>FRP frameworks with <a href="http://slick.typesafe.com/">Slick</a> as a precursor have gained some popularity. They allow to generate SQL queries from a more functional-inspired querying syntax that involve functions like <code>filter()</code> or <code>for ... yield</code> expressions. The following example would correspond to the SQL query <code>SELECT name FROM people</code>.</p><pre class="sourceCode scala"><code>for { p &lt;- people } yield p.name</code></pre><p>Unfortunately, the diverging syntax limits the readability and potential use case scenarios.
  </p><h2 id="our-approach-dsl-and-mapper">Our approach: DSL and Mapper</h2><p>It is worth mentioning that much of the functionality of this framework was inspired by the aforementioned database frameworks.</p><p>The main contribution from ORMs is that mapping classes to and from the database is a huge time saver and leads to code that is more maintainable. From interpolating frameworks we took the idea of an SQL-inspired DSL, but with the requirement of staying as close as possible to its syntax.</p><p>Another design decision was to focus on performance and ease-of-use. Therefore, ScalaRelational does not require you to use a code generator and we have made sure that performance-critical parts don't use <i>reflection</i> internally. There is a <a href="https://github.com/outr/scalarelational-benchmarks">benchmark suite</a> we use to regularly compare the performance against other frameworks.</p><h3 id="dsl-for-querying">DSL for querying</h3><p>For each database table, a schema must be defined which records all available columns and, if a table is polymorphic, its sub-types. Columns are statically typed carrying the underlying SQL database type and the mapped Scala type.</p><p>All query types (like <code>INSERT</code> or <code>UPDATE</code>) have a Scala representation, which require you to refer to your schema and the columns in it. Less common SQL features such as query functions (<code>AVG</code>, <code>MIN</code>, <code>MAX</code> etc.) are supported too.</p><h3 id="mapping">Mapping</h3><p>Additionally, ScalaRelational has a sub-project which implements a feature called <i>mapper</i>. Its purpose is two-fold: mapping column values in <code>SELECT</code> queries to a <code>case class</code> and vice-versa (for <code>INSERT</code> or <code>UPDATE</code> queries).</p><p>If a table has many columns and it is not desired to fetch all column values of a row, ScalaRelational gives the ability to have <code>case class</code>es that define a subset.</p><div><b>Todo:</b> Give an example in some other section</div><p>You can represent different scenarios whether you're querying simple data from one table, querying many columns joined across many tables, or dealing with calculated reports generated by a SQL query.
    </p><h2 id="features">Features</h2><div><b>Todo:</b> Extend this list</div><ul><li>Type-safe table schemas and queries</li><li>Proximity to SQL</li><li>IDE support for queries</li><li>Support for raw SQL queries</li><li>Database-agnostic interface that accounts for differences in SQL implementations</li><li>Modular design</li><li>Optimised for speed</li></ul><h3 id="database-support">Database support</h3><p>Currently supported databases are:

      </p><ul><li>H2</li><li>PostgreSQL <div><b>Todo:</b> Remove from this list?</div></li><li>MariaDB/MySQL</li></ul><p>Other databases technically are supported though certain functionality may require some slight alterations to work properly. If you need support for other databases, please <a href="support.html">get in touch with us</a>.</p>
            <p><small>Generated with <a href="http://github.com/MetaStack-pl/MetaDocs">MetaDocs</a>.</small></p>
          </div>
        </body>
      </html>