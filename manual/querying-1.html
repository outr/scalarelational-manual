<!DOCTYPE html><html lang="en-GB">
        <head>
          <title>ScalaRelational User Manual v1.1.0 - Querying</title>
          <meta charset="utf-8"/>
          <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
          <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
          <meta name="generator" content="MetaDocs"/>
          <link rel="shortcut icon" href="images/favicon.ico"/>
          
          <link rel="stylesheet" type="text/css" href="css/kult.css"/><link rel="stylesheet" type="text/css" href="css/highlight.css"/>
        </head>

        <body>
          <div id="wrapper">
      <header>
            <h1 class="title">ScalaRelational User Manual v1.1.0</h1>
          </header><nav><span>Previous chapter: <a href="mapper.html">Mapper</a></span>  |  <span>Next chapter: <a href="table-definition-1.html">Table definition</a></span></nav><h1 id="querying-1">Querying</h1><h2 id="session-management">Session management</h2><p>All database queries must take place within a <i>session</i>. The session manages the database connection on your behalf.</p><p>Sessions within sessions are valid. ScalaRelational will ignore inner-session creation and only maintain a connection for the outermost session. Additionally, sessions are lazy and will only open a connection when one is needed, so it is perfectly acceptable to wrap blocks of code that may or may not access the database without being concerned about the performance implications.
  </p><h2 id="transactions">Transactions</h2><p>Sessions should not be confused with <i>transactions</i>. A session simply manages the connection whereas a transaction disables <a href="https://en.wikipedia.org/wiki/Autocommit">autocommit</a> and automatically rolls back if an error occurs while executing.</p><h2 id="select">Select</h2><p>We will re-use the database from the previous chapter.</p><p>We've finished inserting data now, so lets start querying some data back out. We'll start by simply iterating over the coffees in the database and printing them out:</p><pre class="sourceCode scala"><code data-lang="scala">import MapperDatastore._
import coffees._

session {
  val query = select (*) from coffees
  query.result.toList.map { r =&gt;
    s&quot;${r(name)}\t${r(supID)}\t${r(price)}\t${r(sales)}\t${r(total)}&quot;
  }
}.mkString(&quot;\n&quot;)</code></pre><b>Output:</b><pre class="sourceCode"><code>Colombian	2	7.99	0	0
French Roast	3	8.99	0	0
Espresso	4	9.99	0	0
Colombian Decaf	2	8.99	0	0
French Roast Decaf	3	9.99	0	0</code></pre><p><code>toList</code> is necessary because <code>result</code> returns a <code>QueryResultsIterator</code> which streams from the database and expects an active session. If you plan to use the rows outside of the session you must convert them to a concrete sequence first.</p><p>It is worthwhile to notice that our query looks exactly like a SQL query, but it is Scala code using ScalaRelational's DSL to provide this. Most of the time SQL queries in ScalaRelational look exactly the same as in SQL, but there are a few more complex scenarios where this is not the case or even not preferred.</p><h3 id="joining">Joining</h3><p>Now that we've seen a basic query example, let's look at a more advanced scenario. We will query all coffees filtering and joining with suppliers:

      </p><pre class="sourceCode scala"><code data-lang="scala">import MapperDatastore._
session {
  val query = (
    select (coffees.name, suppliers.name)
    from coffees
    innerJoin suppliers
    on coffees.supID === suppliers.ref
    where coffees.price &lt; 9.0
  )

  query.result.toList.map { r =&gt;
    s&quot;Coffee: ${r(coffees.name)}, Supplier: ${r(suppliers.name)}&quot;
  }.mkString(&quot;\n&quot;)
}</code></pre><b>Output:</b><pre class="sourceCode"><code>Coffee: Colombian, Supplier: Acme, Inc.
Coffee: French Roast, Supplier: Superior Coffee
Coffee: Colombian Decaf, Supplier: Acme, Inc.</code></pre><p>You can see here that though this query looks very similar to an SQL query there are some slight differences. This is the result of Scala's limitations for writing DSLs. For example, we must use three equal signs (<code>===</code>) instead of two.</p><p>ScalaRelational tries to retain type information where possible, and though loading data by columns is clean, we can actually extract a <code>(String, String)</code> tuple representing the coffee name and suppliers name:</p><pre class="sourceCode scala"><code data-lang="scala">query.result.toList.map { r =&gt;
  val (coffeeName, supplierName) = r()
  s&quot;Coffee: $coffeeName, Supplier: $supplierName&quot;
}</code></pre><p>This is possible because the DSL supports explicit argument lists and retains type information all the way through to the result.
    </p><h2 id="update">Update</h2><p>This is an example for updating a row:

    </p><pre class="sourceCode scala"><code data-lang="scala">val query = update (name(&quot;updated name&quot;)) where id === 1
query.result</code></pre><h2 id="delete">Delete</h2><p>In analogy to updating rows, a deletion looks as follows:

    </p><pre class="sourceCode scala"><code data-lang="scala">val query = delete (triggerTest) where triggerTest.id === 1
query.result</code></pre><h2 id="sql-functions">SQL functions</h2><p>ScalaRelational supports SQL functions such as <code>avg</code>. These are defined directly on the columns.</p><pre class="sourceCode scala"><code data-lang="scala">import coffees._
  session {
    (select (rating.avg) from coffees)
      .result.one(rating.avg).get
  }</code></pre>
      <p><small>Generated with <a href="http://github.com/MetaStack-pl/MetaDocs">MetaDocs</a></small></p>
    </div>
          <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="js/main.js"></script><script src="js/highlight.js"></script>
          <script>hljs.initHighlightingOnLoad();</script>
        </body>
      </html>