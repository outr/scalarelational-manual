chapter[id=mapper,Mapper] {
  The mapper module provides functionality to map table rows when persisting or selecting rows.

  section[sbt dependency] {
    We must first add another dependency to our build file:

    sbt[project=h2mapper] {
      libraryDependencies += "org.scalarelational" %% "scalarelational-mapper" % "1.1.0-SNAPSHOT"
    }

    sbt[project=h2mapper,hidden=yes] {
      libraryDependencies += "org.scalarelational" %% "scalarelational-h2" % "1.1.0-SNAPSHOT"
    }
  }

  section[Library imports] {
    For the mapper you need the following additional import:

    scala[global=yes,project=h2mapper]{*
      import org.scalarelational.mapper._
    *}

    scala[global=yes,project=h2mapper,hidden=yes]{*
      import org.scalarelational.column.property._
      import org.scalarelational.h2.{H2Datastore, H2Memory}
      import org.scalarelational.table.Table
      import org.scalarelational.datatype.Ref
      import org.powerscala.enum.{EnumEntry, Enumerated}
    *}
  }

  section[Table definition] {
    When defining a table definition with the mapper, the key difference is that you need to use code{MappedTable}  and supply the code{case class} you want to map it to. We change the example from the previous chapter to:

    scala[global=yes,project=h2mapper]{*
      object MapperDatastore extends H2Datastore(mode = H2Memory("mapper")) {
        object suppliers extends MappedTable[Supplier]("SUPPLIERS") {
          val name = column[String]("SUP_NAME", Unique)
          val street = column[String]("STREET")
          val city = column[String]("CITY")
          val state = column[Option[String], String]("STATE")
          val zip = column[String]("ZIP")
          val status = column[Status, String]("STATUS")
          val id = column[Option[Int], Int]("SUP_ID", PrimaryKey, AutoIncrement)
        }

        object coffees extends MappedTable[Coffee]("COFFEES") {
          val name = column[String]("COF_NAME", Unique)
          val supID = column[Ref[Supplier], Int]("SUP_ID", new ForeignKey(suppliers.id))
          val price = column[Double]("PRICE")
          val sales = column[Int]("SALES")
          val total = column[Int]("TOTAL")
          val id = column[Option[Int], Int]("COF_ID", PrimaryKey, AutoIncrement)
        }
      }
    *}

    You may have noticed that the supplier ID in code{coffees} now has a type-safe reference. The second type argument of code{colum} denotes the underlying SQL type, which in case of foreign keys is an integer. todo{What about non-integer FKs?}

    We also added a new field code{status} to show how the following enumeration can be used in a table:

    scala[global=yes,project=h2mapper] {*
      sealed abstract class Status extends EnumEntry

      object Status extends Enumerated[Status] {
        case object Unconfirmed extends Status
        case object Disabled extends Status
        case object Enabled extends Status

        val values = findValues.toVector
      }
    *}

    subsection[Creating table] {
      As previously, create the tables using code{create}:

      scala[project=h2mapper] {*
        import MapperDatastore._

        session {
          create(suppliers, coffees)
        }
      *}
    }
  }

  section[Entities] {
    Along with the table definition, you have to declare an accompanying code{case class}, which is called i{entity}. An entity needs to contain exactly the same columns as the table and the columns must have the same types.

    A code{case class} needs to extend from code{Entity}. Furthermore, it needs to define the table that the columns map to.

    scala[global=yes,project=h2mapper] {*
      case class Supplier(name: String,
                          street: String,
                          city: String,
                          state: Option[String],
                          zip: String,
                          status: Status,
                          id: Option[Int] = None) extends Entity[Supplier] {
        def columns = mapTo[Supplier](MapperDatastore.suppliers)
      }

      case class Coffee(name: String,
                        supID: Ref[Supplier],
                        price: Double,
                        sales: Int,
                        total: Int,
                        id: Option[Int] = None) extends Entity[Coffee] {
        def columns = mapTo[Coffee](MapperDatastore.coffees)
      }
    *}

    Though all of these fields are in the same order as the table, this is not required to be the case. Mapping takes place based on the field name to the column name in the table, so order doesn't matter.
  }

  section[Insert] {
    We've create a code{Supplier} case class, but now we need to create an instance and insert it into the database:

    scala[project=h2mapper,printResult=yes] {*
      import MapperDatastore._
      session {
        val starbucks = Supplier("Starbucks", "123 Everywhere Rd.", "Lotsaplaces",
          Some("CA"), "93966", Status.Enabled)
        starbucks.insert.result
      }
    *}

    It is worth noting here that the result is the database-generated primary key.

    Now define some global IDs first that we will use throughout this chapter:

    scala[global=yes,project=h2mapper] {*
      object Ids {
        var acmeId: Int = _
        var superiorCoffeeId: Int = _
        var theHighGroundId: Int = _
      }
    *}

    And insert some suppliers:

    scala[project=h2mapper,printResult=yes] {*
      import MapperDatastore._
      import suppliers._
      import Ids._

      transaction {
        // Clean and type-safe inserts
        acmeId = insert(name("Acme, Inc."), street("99 Market Street"),
          city("Groundsville"), state(Some("CA")), status(Status.Unconfirmed),
          zip("95199")).result
        superiorCoffeeId = insert(name("Superior Coffee"), street("1 Party Place"),
          city("Mendocino"), zip("95460"), status(Status.Unconfirmed)).result

        // Short-hand when using values in order - we exclude the id since it
        // will be generated by the database
        theHighGroundId = insertInto(suppliers, "The High Ground", "100 Coffee Lane",
          "Meadows", Some("CA"), "93966", Status.Unconfirmed).result

        (acmeId, superiorCoffeeId, theHighGroundId)
      }
    *}

    Two insert styles are represented here. The first uses the column to wrap around a value to instantiate the column with a value. This provides a clean way of inserting the exact values you need and excluding values you want defaulted.

    The second representation uses code{insertInto} and takes the code{Table} as the first argument followed by the values to be inserted. For code{insertInto} the items must be added in the same order as they are defined in your Table. This second method is provided mostly for people coming from Slick as it provides a very similar approach, but the first method is preferred as there is no ambiguity of what value maps to what column and offers greater inserting flexibility.

    The last thing to notice here is that instead of a code{session} we are using a code{transaction}. Because we are inserting multiple suppliers we want to make sure everything inserts properly or rolls the entire transaction back. You can use code{transaction} instead of code{session} as a code{transaction} establishes a code{session} if one does not already exist.
  }

  section[Batch inserting] {
    Now that we have some suppliers, we need to add some coffees as well:

    scala[project=h2mapper,printResult=yes] {*
      import MapperDatastore._
      import coffees._
      import Ids._

      session {
        insert(name("Colombian"), supID(Ref[Supplier](acmeId)), price(7.99), sales(0), total(0)).
          and(name("French Roast"), supID(Ref[Supplier](superiorCoffeeId)), price(8.99), sales(0), total(0)).
          and(name("Espresso"), supID(Ref[Supplier](theHighGroundId)), price(9.99), sales(0), total(0)).
          and(name("Colombian Decaf"), supID(Ref[Supplier](acmeId)), price(8.99), sales(0), total(0)).
          and(name("French Roast Decaf"), supID(Ref[Supplier](superiorCoffeeId)), price(9.99), sales(0), total(0)).result
      }
    *}

    todo{Why does it return 5 in a code{List}?}

    Note that we need to use type-safe references for the suppliers.
  }

  section[Query] {
    We've successfully inserted our code{Supplier} instance. The syntax for querying it back out is similar to SQL:

    scala[project=h2mapper,printResult=yes] {*
      import MapperDatastore._
      import suppliers._

      session {
        val query = select (*) from suppliers where name === "Starbucks"
        query.to[Supplier].result.head()
      }
    *}

    The mapper will automatically match column names in the results to fields in the code{case class} provided. Every query can have its own class for convenience mapping.

    subsection[Using references] {
      Use code{ref} on a table definition to obtain its reference. It can then be used in queries and compared to foreign key columns like code{supID}.

      scala[project=h2mapper,printResult=yes] {*
        import MapperDatastore._
        session {
          val query = (
            select (coffees.name, suppliers.name)
              from coffees
              innerJoin suppliers
              on coffees.supID === suppliers.ref
          )
          query.result.toList.mkString("\n")
        }
      *}
    }

    subsection[Using joins] {
      Joins are one of the major points where ScalaRelational diverges from other frameworks that have a concept of an ORM:

      scala[project=h2mapper,printResult=yes] {*
        import MapperDatastore._
        session {
          val query = (
            select (coffees.* ::: suppliers.*)
            from coffees
            innerJoin suppliers
            on (coffees.supID === suppliers.ref)
            where coffees.name === "French Roast"
          )

          val (frenchRoast, superior) =
            query.to[Coffee, Supplier](coffees, suppliers).result.head()
          s"Coffee: $frenchRoast\nSupplier: $superior"
        }
      *}

      This is an efficient SQL query to join the code{coffees} table with the code{suppliers} table and get back a single result set. Using the mapper we are able to separate the columns relating to code{coffees} from code{suppliers} and map them directly to our code{case class}es.
    }
  }

  section[Polymorphic tables] {
    It may be desired to represent a type hierarchy in a single table for better performance:

    scala[global=yes,project=h2mapper] {*
      trait User {
        def name: String
        def id: Option[Int]
      }

      case class UserGuest(name: String, id: Option[Int] = None)
        extends User with Entity[UserGuest]
      {
        def columns = mapTo[UserGuest](users)
        val isGuest = true
      }

      case class UserAdmin(name: String, canDelete: Boolean, id: Option[Int] = None)
        extends User with Entity[UserAdmin]
      {
        def columns = mapTo[UserAdmin](users)
        val isGuest = false
      }

      object users extends MappedTable[User]("users")(MapperDatastore) {
        val id = column[Option[Int], Int]("id", PrimaryKey, AutoIncrement)
        val name = column[String]("name")
        val canDelete = column[Boolean]("canDelete", Polymorphic)
        val isGuest = column[Boolean]("isGuest")
      }
    *}

    Create the tables:

    scala[project=h2mapper] {*
      import MapperDatastore._

      session {
        create(users)
      }
    *}

    Now you can insert a heterogeneous list of entities:

    scala[project=h2mapper] {*
      val insertUsers = Seq(
        UserGuest("guest"),
        UserAdmin("admin", true)
      )

      import MapperDatastore._

      session {
        insertUsers.foreach(_.insert.result)
      }
    *}

    To query the table, you will need to evaluate the column which encodes the original type of the object, namely code{isGuest} in this case. For more complex type hierarchies you may want to use an enumeration instead of a boolean flag.

    scala[project=h2mapper,printResult=yes] {*
      import MapperDatastore._
      val query = users.q from users

      val x = query.asCase[User] { row =>
        if (row(users.isGuest)) classOf[UserGuest]
        else classOf[UserAdmin]
      }

      session {
        x.result.converted.toList.mkString("\n")
      }
    *}
  }
}
