chapter[Table definition] {
  todo{Check and complete chapter}

  section[Mapper] {
    See the chapter jump[mapper]{} for more information.
  }

  section[Column types] {
    subsection[References] {
      References are a type-safe abstraction for foreign keys:

      scala {*
        val supID = column[Ref[Supplier], Int]("SUP_ID", new ForeignKey(suppliers.id))
      *}

      You can call code{ref} on every table to obtain its reference.
    }

    subsection[Option] {
      We prevent code{null} pointers by introducing an optional column type:

      scala {*
        val id = column[Option[Int], Int]("COF_ID", PrimaryKey, AutoIncrement)
      *}

      The second type parameter denotes the underlying SQL type.

      You can call code{opt} on every column to obtain its values wrapped in an optional column type. This is sometimes necessary when comparing an optional column with a non-optional column in a query:

      scala {*
        val query = (
          select (*)
          from coffees
          innerJoin suppliers
          on suppliers.id === supID.opt
        )
      *}
    }

    subsection[Enumeration] {
      You need these two imports:

      scala {*
        import org.powerscala.enum.{EnumEntry, Enumerated}
      *}

      An enumeration may look like:

      scala {*
        sealed abstract class Status extends EnumEntry

        object Status extends Enumerated[Status] {
          case object Disabled extends Status
          case object Enabled extends Status

          val values = findValues.toVector
        }
      *}

      Use the enumeration in a column like this:

      scala {
        val status = column[Status, String]("STATUS")
      }

      The underlying SQL type of enumerations is a string.
    }

    subsection[Blobs] {
      A column serialising an object looks as follows:

      scala {*
        val fruit = column[Fruit, Blob]("fruit",
          ObjectSerializationDataTypeCreator.create[Fruit])
      *}

      There is also an untyped code{Blob} column type:

      scala {*
        val content = column[Blob]("content")
      *}
    }

    subsection[id=custom-column-type,Defining a custom type] {
      todo{Extend section}
      Example for storing string lists in a code{VARCHAR} column:

      scala {*
        object ListConverter extends SQLConversion[List[String], String] {
          override def toSQL(column: ColumnLike[List[String], String], value: List[String]): String = value.mkString("|")
          override def fromSQL(column: ColumnLike[List[String], String], value: String): List[String] = value.split('|').toList
        }
        implicit def listDataType = new DataType[List[String], String](Types.VARCHAR, SQLType("VARCHAR(1024)"), ListConverter)
      *}
    }
  }

  section[Column properties] {
    subsection[Unique values] {
      Example:

      scala {*
        val name = column[String]("name", Unique)
      *}
    }

    subsection[id=custom-column-length,Custom column length] {
      The pre-defined column types use heuristic values for the default column lengths. It may happen that the default value is not a good fit. You can change this by passing the column property code{ColumnLength}:

      scala {*
        val name = column[String]("name", ColumnLength(200))
      *}
    }
  }

  section[Versioning] {
    Add code{with VersioningSupport} to your datastore definition and define a new upgrade instance for every new version:

    scala {*
      object Upgrade4 extends UpgradableVersion {
        override def version = 4
        override def upgrade() = {
          import VersioningDatastore._

          createTable("test").
            and(createColumn[Int]("test2", "id", PrimaryKey, AutoIncrement)).
            and(createColumn[String]("test2", "name")).
            and(createColumn[Option[Int], Int]("test2", "age")).result
        }
      }
    *}

    todo{We have to describe the table creation DSL}

    Within the datastore, call code{register} for all upgrade objects:

    scala {*
      register(Upgrade3)
      register(Upgrade4)
    *}

    To obtain the current version, use code{version()}. To upgrade to the latest version, call code{upgrade()} in a session.
  }
}
