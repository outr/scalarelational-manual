chapter[Querying] {
  section[id=session-management,Session management] {
    All database queries must take place within a i{session}. The session manages the database connection on your behalf.

    Sessions within sessions are valid. ScalaRelational will ignore inner-session creation and only maintain a connection for the outermost session. Additionally, sessions are lazy and will only open a connection when one is needed, so it is perfectly acceptable to wrap blocks of code that may or may not access the database without being concerned about the performance implications.
  }

  section[Transactions] {
    Sessions should not be confused with i{transactions}. A session simply manages the connection whereas a transaction disables url[https://en.wikipedia.org/wiki/Autocommit]{autocommit} and automatically rolls back if an error occurs while executing.
  }

  section[Select] {
    We will re-use the database from the previous chapter.

    We've finished inserting data now, so lets start querying some data back out. We'll start by simply iterating over the coffees in the database and printing them out:

    scala[project=h2mapper,printResult=yes] {*
      import MapperDatastore._
      import coffees._

      session {
        val query = select (*) from coffees
        query.result.toList.map { r =>
          s"${r(name)}\t${r(supID)}\t${r(price)}\t${r(sales)}\t${r(total)}"
        }
      }.mkString("\n")
    *}

    code{toList} is necessary because code{result} returns a code{QueryResultsIterator} which streams from the database and expects an active session. If you plan to use the rows outside of the session you must convert them to a concrete sequence first.

    It is worthwhile to notice that our query looks exactly like a SQL query, but it is Scala code using ScalaRelational's DSL to provide this. Most of the time SQL queries in ScalaRelational look exactly the same as in SQL, but there are a few more complex scenarios where this is not the case or even not preferred.

    subsection[Joining] {
      Now that we've seen a basic query example, let's look at a more advanced scenario. We will query all coffees filtering and joining with suppliers:

      scala[project=h2mapper,printResult=yes] {*
        import MapperDatastore._
        session {
          val query = (
            select (coffees.name, suppliers.name)
            from coffees
            innerJoin suppliers
            on coffees.supID === suppliers.ref
            where coffees.price < 9.0
          )

          query.result.toList.map { r =>
            s"Coffee: ${r(coffees.name)}, Supplier: ${r(suppliers.name)}"
          }.mkString("\n")
        }
      *}

      You can see here that though this query looks very similar to an SQL query there are some slight differences. This is the result of Scala's limitations for writing DSLs. For example, we must use three equal signs (code{===}) instead of two.

      ScalaRelational tries to retain type information where possible, and though loading data by columns is clean, we can actually extract a code{(String, String)} tuple representing the coffee name and suppliers name:

      scala {*
        query.result.toList.map { r =>
          val (coffeeName, supplierName) = r()
          s"Coffee: $coffeeName, Supplier: $supplierName"
        }
      *}

      This is possible because the DSL supports explicit argument lists and retains type information all the way through to the result.
    }
  }

  section[Update] {
    This is an example for updating a row:

    scala {*
      val query = update (name("updated name")) where id === 1
      query.result
    *}
  }

  section[Delete] {
    In analogy to updating rows, a deletion looks as follows:

    scala {*
      val query = delete (triggerTest) where triggerTest.id === 1
      query.result
    *}
  }

  section[SQL functions] {
    ScalaRelational supports SQL functions such as code{avg}. These are defined directly on the columns.

    scala {*
      import coffees._
        session {
          (select (rating.avg) from coffees)
            .result.one(rating.avg).get
        }
    *}
  }
}
